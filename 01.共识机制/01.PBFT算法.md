##  PBFT算法

### 引言

区块链系统，首先是一个分布式系统。传统单节点结构演变到分布式系统，碰到的首要问题就是一致性的保障。很显然，如果分布式集群无法保证处理结果一致的话，那任何建立于其上的业务系统都无法正常工作。

通过PBFT算法，不采用签名的方式，最多容忍不超过全部节点的1/3问题节点，来解决拜占庭问题

### 算法原理

![img](imags\a14.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

 图13

简单理解：

1. 客户端向主节点发送请求操作消息, 主节点接收到请求操作消息并校验正确后, 保存该消息, 并依据该请求操作消息生成预准备消息, 广播给各备份节点.
2. 各备份节点接收到预准备消息并校验正确后, 保存该消息, 并以该预准备消息为依据, 生成准备消息广播给主节点和其他备份节点.
3. 各存储副本的节点接收到准备消息并校验正确后, 保存该消息, 并以该准备消息为依据, 生成提交消息给客户端、主节点和其他备份节点.
4. 各存储副本的节点接收到 (2n + 1)/3 个提交消息并校验正确后, 则执行来自客户端的请求操作消息里的操作.
5. 客户端接收到 (n + 2)/3 个提交消息, 验证正确并接受后, 便认为该消息已被副本节点集群所承认与执行. 这里的客户端接受 (n + 2)/3 个提交消息而不是 (2n + 1)/3 个的原因在于失效的节点数量不超过 (n − 1)/3, 因此 (n − 1)/3 + 1 个一致响应必定能够保证结果是正确的.

深入理解：

1. REQUEST：客户端c向主节点p发送<REQUEST, o, t, c>请求。o: 请求的具体操作，t: 请求时客户端追加的时间戳，c：客户端标识。REQUEST: 包含消息内容m，以及消息摘要d(m)。客户端对请求进行签名。
2. PRE-PREPARE：主节点收到客户端的请求，需要进行以下校验： 
   1. 客户端请求消息签名是否正确：非法请求丢弃。正确请求，分配一个编号n，编号n主要用于对客户端的请求进行排序。然后广播一条<<PRE-PREPARE, v, n, d>, m>消息给其他副本节点。v：视图编号，d客户端消息摘要，m消息内容。<PRE-PREPARE, v, n, d>进行主节点签名。n是要在某一个范围区间内的[h, H]，具体原因参见*垃圾回收*章节。
3. PREPARE：副本节点i收到主节点的PRE-PREPARE消息，需要进行以下校验： 
   1. 主节点PRE-PREPARE消息签名是否正确。
   2. 当前副本节点是否已经收到了一条在同一v下并且编号也是n，但是签名不同的PRE-PREPARE信息。
   3. d与m的摘要是否一致。
   4. n是否在区间[h, H]内。
   5. 总结：非法请求丢弃。正确请求，副本节点i向其他节点包括主节点发送一条<PREPARE, v, n, d, i>消息, v, n, d, m与上述PRE-PREPARE消息内容相同，i是当前副本节点编号。<PREPARE, v, n, d, i>进行副本节点i的签名。记录PRE-PREPARE和PREPARE消息到log中，用于View Change过程中恢复未完成的请求操作。
4. COMMIT：主节点和副本节点收到PREPARE消息，需要进行以下校验： 
   1. 副本节点PREPARE消息签名是否正确。
   2. 当前副本节点是否已经收到了同一视图v下的n。
   3. n是否在区间[h, H]内。
   4. d是否和当前已收到PRE-PPREPARE中的d相同
   5. 总结：非法请求丢弃。如果副本节点i收到了2f+1个验证通过的PREPARE消息，则向其他节点包括主节点发送一条<COMMIT, v, n, d, i>消息，v, n, d, i与上述PREPARE消息内容相同。<COMMIT, v, n, d, i>进行副本节点i的签名。记录COMMIT消息到日志中，用于View Change过程中恢复未完成的请求操作。记录其他副本节点发送的PREPARE消息到log中。
5. REPLY：主节点和副本节点收到COMMIT消息，需要进行以下校验： 
   1. 副本节点COMMIT消息签名是否正确。
   2. 当前副本节点是否已经收到了同一视图v下的n。
   3. d与m的摘要是否一致。
   4. n是否在区间[h, H]内。
   5. 总结：非法请求丢弃。如果副本节点i收到了2f+1个验证通过的COMMIT消息，说明当前网络中的大部分节点已经达成共识，运行客户端的请求操作o，并返回<REPLY, v, t, c, i, r>给客户端，r：是请求操作结果，客户端如果收到f+1个相同的REPLY消息，说明客户端发起的请求已经达成全网共识，否则客户端需要判断是否重新发送请求给主节点。记录其他副本节点发送的COMMIT消息到log中。

### 垃圾回收机制

在上述算法流程中，为了确保在View Change的过程中，能够恢复先前的请求，每一个副本节点都记录一些消息到本地的log中，当执行请求后副本节点需要把之前该请求的记录消息清除掉。最简单的做法是在Reply消息后，再执行一次当前状态的共识同步，这样做的成本比较高，因此可以在执行完多条请求K（例如：100条）后执行一次状态同步。这个状态同步消息就是CheckPoint消息。

副本节点i发送<CheckPoint, n, d, i>给其他节点，n是当前节点所保留的最后一个视图请求编号，d是对当前状态的一个摘要，该CheckPoint消息记录到log中。如果副本节点i收到了2f+1个验证过的CheckPoint消息，则清除先前日志中的消息，并以n作为当前一个stable checkpoint。

这是理想情况，实际上当副本节点i向其他节点发出CheckPoint消息后，其他节点还没有完成K条请求，所以不会立即对i的请求作出响应，它还会按照自己的节奏，向前行进，但此时发出的CheckPoint并未形成stable，为了防止i的处理请求过快，设置一个上文提到的高低水位区间[h, H]来解决这个问题。低水位h等于上一个stable checkpoint的编号，高水位H = h + L，其中L是我们指定的数值，等于checkpoint周期处理请求数K的整数倍，可以设置为L = 2K。当副本节点i处理请求超过高水位H时，此时就会停止脚步，等待stable checkpoint发生变化，再继续前进。

### view change

对于view change，其作用主要有两点:①、防止主节点是恶意节点的时候导致不能达成共识，从而保证算法的liveness;②防止主节点是故障节点导致在一定时间内，分布式系统不能完成共识，系统等待。
 View Change的核心因素只有一个：怀疑当前的主节点在有限的时间内，无法达成一致

如果主节点作恶，它可能会给不同的请求编上相同的序号，或者不去分配序号，或者让相邻的序号不连续。备份节点应当有职责来主动检查这些序号的合法性。如果主节点掉线或者作恶不广播客户端的请求，客户端设置超时机制，超时的话，向所有副本节点广播请求消息。副本节点检测出主节点作恶或者下线，发起View Change协议。

副本节点向其他节点广播<VIEW-CHANGE, v+1, n, *C*, *P*, i>消息。n是最新的stable checkpoint的编号，*C***是**2f+1验证过的CheckPoint消息集合，*P*是当前副本节点未完成的请求的PRE-PREPARE和PREPARE消息集合。

当主节点p = v + 1 mod |R|收到2f个有效的VIEW-CHANGE消息后，向其他节点广播<NEW-VIEW, v+1, *V*, *O*>消息。*V*是有效的VIEW-CHANGE消息集合。*O*是主节点重新发起的未经完成的PRE-PREPARE消息集合。PRE-PREPARE消息集合的选取规则：

\1. 选取*V*中最小的stable checkpoint编号min-s，选取*V*中prepare消息的最大编号max-s。

\2. 在min-s和max-s之间，如果存在*P*消息集合，则创建<<PRE-PREPARE, v+1, n, d>, m>消息。否则创建一个空的PRE-PREPARE消息，即：<<PRE-PREPARE, v+1, n, d(null)>, m(null)>, m(null)空消息，d(null)空消息摘要。

副本节点收到主节点的NEW-VIEW消息，验证有效性，有效的话，进入v+1状态，并且开始*O*中的PRE-PREPARE消息处理流程。

![img](imags\a15.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

图14